<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <title>React Hook | tiger BeA</title>
    <meta name="description" content="">
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/assets/logo.svg">
    <meta name="description" content="个人笔记">
    <link rel="preload" href="/assets/css/0.styles.299fb9f2.css" as="style"><link rel="preload" href="/assets/js/app.f6cea7aa.js" as="script"><link rel="preload" href="/assets/js/2.d7b159a0.js" as="script"><link rel="preload" href="/assets/js/13.a8053161.js" as="script"><link rel="prefetch" href="/assets/js/10.18f7d877.js"><link rel="prefetch" href="/assets/js/11.0112076c.js"><link rel="prefetch" href="/assets/js/12.b0386b46.js"><link rel="prefetch" href="/assets/js/14.5d36b6d3.js"><link rel="prefetch" href="/assets/js/15.cf5b162b.js"><link rel="prefetch" href="/assets/js/16.844d7a2a.js"><link rel="prefetch" href="/assets/js/17.09f65d83.js"><link rel="prefetch" href="/assets/js/3.fd9c5d47.js"><link rel="prefetch" href="/assets/js/4.1d153079.js"><link rel="prefetch" href="/assets/js/5.ebadb9e3.js"><link rel="prefetch" href="/assets/js/6.29cd37cb.js"><link rel="prefetch" href="/assets/js/7.cd5bf533.js"><link rel="prefetch" href="/assets/js/8.8d754837.js"><link rel="prefetch" href="/assets/js/9.8e681e20.js">
    <link rel="stylesheet" href="/assets/css/0.styles.299fb9f2.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="ant-row"><div class="nav-button"><i aria-label="icon: bars" class="anticon anticon-bars"><svg viewBox="0 0 1024 1024" focusable="false" data-icon="bars" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M912 192H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zm0 284H328c-4.4 0-8 3.6-8 8v56c0 4.4 3.6 8 8 8h584c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM104 228a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0zm0 284a56 56 0 1 0 112 0 56 56 0 1 0-112 0z"></path></svg></i> <span></span></div> <div class="ant-col ant-col-xs-24 ant-col-sm-24 ant-col-md-6 ant-col-lg-5 ant-col-xl-5 ant-col-xxl-4"><a href="/" class="router-link-active no-logo home-link"><!----> <span class="site-name">tiger BeA</span></a> <div class="search-box mobile-search"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div></div> <div class="ant-col ant-col-xs-0 ant-col-sm-0 ant-col-md-18 ant-col-lg-19 ant-col-xl-19 ant-col-xxl-20"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><ul role="menu" id="nav" class="ant-menu ant-menu-horizontal ant-menu-root ant-menu-light"><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/" class="router-link-active">
          首页
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-submenu-selected"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>
          技术
        </span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li role="menuitem" class="ant-menu-item"><a href="/gardening/">
          园艺
        </a></li><li role="menuitem" class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute;"><div aria-haspopup="true" class="ant-menu-submenu-title"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul> <a href="https://github.com/tiger-BeA?tab=repositories" target="_blank" rel="noopener noreferrer" class="repo-link"><i aria-label="icon: github" class="anticon anticon-github"><svg viewBox="64 64 896 896" focusable="false" data-icon="github" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M511.6 76.3C264.3 76.2 64 276.4 64 523.5 64 718.9 189.3 885 363.8 946c23.5 5.9 19.9-10.8 19.9-22.2v-77.5c-135.7 15.9-141.2-73.9-150.3-88.9C215 726 171.5 718 184.5 703c30.9-15.9 62.4 4 98.9 57.9 26.4 39.1 77.9 32.5 104 26 5.7-23.5 17.9-44.5 34.7-60.8-140.6-25.2-199.2-111-199.2-213 0-49.5 16.3-95 48.3-131.7-20.4-60.5 1.9-112.3 4.9-120 58.1-5.2 118.5 41.6 123.2 45.3 33-8.9 70.7-13.6 112.9-13.6 42.4 0 80.2 4.9 113.5 13.9 11.3-8.6 67.3-48.8 121.3-43.9 2.9 7.7 24.7 58.3 5.5 118 32.4 36.8 48.9 82.7 48.9 132.3 0 102.2-59 188.1-200 212.9a127.5 127.5 0 0 1 38.1 91v112.5c.8 9 0 17.9 15 17.9 177.1-59.7 304.6-227 304.6-424.1 0-247.2-200.4-447.3-447.5-447.3z"></path></svg></i></a></nav></div></div> <!----></header> <aside class="sidebar"><!----> <ul class="sidebar-links"><li><a href="/technology/front-end/" aria-current="page" title="前端" class="sidebar-link">前端</a></li><li><a href="/technology/front-end/h5-autoplay-audio.html" title="H5 端背景音乐自动播放" class="sidebar-link">H5 端背景音乐自动播放</a></li><li><a href="/technology/front-end/phaser3.html" title="Phaser 3" class="sidebar-link">Phaser 3</a></li><li><a href="/technology/front-end/react-hook.html" aria-current="page" title="React Hook" class="active sidebar-link">React Hook</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/technology/front-end/react-hook.html#function-vs-class" title="Function Vs Class" class="sidebar-link">Function Vs Class</a></li><li class="sidebar-sub-header"><a href="/technology/front-end/react-hook.html#hooks-的实现和使用" title="Hooks 的实现和使用" class="sidebar-link">Hooks 的实现和使用</a></li><li class="sidebar-sub-header"><a href="/technology/front-end/react-hook.html#性能优化相关-hooks" title="性能优化相关 Hooks" class="sidebar-link">性能优化相关 Hooks</a></li><li class="sidebar-sub-header"><a href="/technology/front-end/react-hook.html#其他-hooks-api" title="其他 Hooks API" class="sidebar-link">其他 Hooks API</a></li><li class="sidebar-sub-header"><a href="/technology/front-end/react-hook.html#自定义-hook" title="自定义 Hook" class="sidebar-link">自定义 Hook</a></li><li class="sidebar-sub-header"><a href="/technology/front-end/react-hook.html#function-组件的-defaultprops" title="Function 组件的 defaultProps" class="sidebar-link">Function 组件的 defaultProps</a></li><li class="sidebar-sub-header"><a href="/technology/front-end/react-hook.html#注意事项-2" title="注意事项" class="sidebar-link">注意事项</a></li></ul></li><li><a href="/technology/front-end/rxjs-operator.html" title="RxJs 操作符" class="sidebar-link">RxJs 操作符</a></li></ul></aside> <main class="page"> <div class="theme-antdocs-content content__default"><h1 id="react-hook"><a href="#react-hook" class="header-anchor">#</a> React Hook</h1> <h2 id="function-vs-class"><a href="#function-vs-class" class="header-anchor">#</a> Function Vs Class</h2> <h3 id="class-组件的缺陷"><a href="#class-组件的缺陷" class="header-anchor">#</a> Class 组件的缺陷</h3> <ol><li>this 的指向<br><img src="https://img-pub.fbcontent.cn/1634788362091_vlneswhzs.png" style="zoom:50%;"></li> <li>编译后的可读性差且性能不好
<ol><li>js 本身实现的类比较鸡肋</li> <li>class 组件在 react 内部实际还是当做 Function 类来处理的</li></ol></li></ol> <h3 id="function-组件的缺陷"><a href="#function-组件的缺陷" class="header-anchor">#</a> Function 组件的缺陷</h3> <ol><li>function 本身无状态无存储，依赖 props 传入来响应变更，故而最外层还是得依赖一个 class component</li></ol> <h3 id="function-hook"><a href="#function-hook" class="header-anchor">#</a> Function + hook</h3> <p>要解决 function 的缺陷，关键在于让 function 组件自身具备状态处理的能力，即组件首次 render 后，能够通过某种机制再次触发自身状态变更，实现 re-render，即 hooks</p> <p>hooks 诞生的原因就是为了便于静态分析依赖，简化 immutable 数据流的使用成本</p> <h2 id="hooks-的实现和使用"><a href="#hooks-的实现和使用" class="header-anchor">#</a> Hooks 的实现和使用</h2> <h3 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h3> <h4 id="fiber-是什么"><a href="#fiber-是什么" class="header-anchor">#</a> Fiber 是什么？</h4> <p>Fiber 是 react16 中的协调引擎，主要目的是使 virtual dom 可以进行增量式渲染</p> <h4 id="注意事项"><a href="#注意事项" class="header-anchor">#</a> 注意事项</h4> <ul><li>只能在 function 组件中使用 hook</li> <li>必须在函数组件顶部作用域调用 hooks api
<ul><li>state 是一个对象，对应 <code>FiberNode</code> 中的 <code>memoizedState</code>属性，在 class 组件中调用 <code>setState()</code>时等同于更新 <code>memoizedState</code>，但在 functino 组件中， <code>memoizedState</code>被设计成一个链表。首次 render 后，react 就初始化了一个 Fiber 链表结构，之后只能通过<code>useState</code>这个 hook 返回的 dispatch 修改对应 FiberNode<code>的</code>memoizedState，因此必须要保证 hooks 顺序不变（对应链表的结点不变，才能修改作用到正确的链表结点上），故而只有放在顶层调用才能保证各个 hooks 的执行顺序</li></ul></li></ul> <h3 id="usecontext"><a href="#usecontext" class="header-anchor">#</a> UseContext</h3> <h4 id="api-示例"><a href="#api-示例" class="header-anchor">#</a> API 示例</h4> <div class="language-react extra-class"><pre class="language-text"><code>const themes = {
  light: {
    foreground: &quot;#000000&quot;,
    background: &quot;#eeeeee&quot;
  },
  dark: {
    foreground: &quot;#ffffff&quot;,
    background: &quot;#222222&quot;
  }
};

// 提供默认值 themes.light
const ThemeContext = React.createContext(themes.light);

function App() {
  return (
    &lt;ThemeContext.Provider value={themes.dark}&gt;
      &lt;Toolbar /&gt;
    &lt;/ThemeContext.Provider&gt;
  );
}

function Toolbar(props) {
  return (
    &lt;div&gt;
      &lt;ThemedButton /&gt;
    &lt;/div&gt;
  );
}

function ThemedButton() {
  // 获取最近父元素上 provider 上获取的值，这里为 dark
  const theme = useContext(ThemeContext);
  return (
    &lt;button style={{ background: theme.background, color: theme.foreground }}&gt;
      I am styled by theme context!
    &lt;/button&gt;
  );
}
</code></pre></div><h4 id="应用场景"><a href="#应用场景" class="header-anchor">#</a> 应用场景</h4> <p>方便组件之间状态共享，不用再层层传递</p> <h4 id="q-a"><a href="#q-a" class="header-anchor">#</a> Q&amp;A</h4> <h5 id="状态管理方案如何选取-context-是否可以代替-redux"><a href="#状态管理方案如何选取-context-是否可以代替-redux" class="header-anchor">#</a> 状态管理方案如何选取？context 是否可以代替 redux？</h5> <h3 id="useeffect"><a href="#useeffect" class="header-anchor">#</a> UseEffect</h3> <h4 id="api-示例-2"><a href="#api-示例-2" class="header-anchor">#</a> API 示例</h4> <div class="language-react extra-class"><pre class="language-text"><code>useEffect(() =&gt; {
  const subscription = props.source.subscribe();
  return () =&gt; {
    subscription.unsubscribe();
  }
  // effect 的 deps 数组项，发生变化时才会触发重新创建
}, [props.source]);
</code></pre></div><p>需要在[]中声明所有在外部作用域中发生变化且在 effect 中使用到的变量，否则就会引用到先前渲染中的旧变量</p> <h4 id="应用场景-2"><a href="#应用场景-2" class="header-anchor">#</a> 应用场景</h4> <p>处理 function 组件中的副作用，如异步操作、延迟操作等，可以替代 class 组件的 <code>componentDidMount</code>、<code>componentDidUpdate</code>、<code>componentWillUnmount</code> 等生命周期，发生在<strong>组件被渲染为真实 DOM 后执行</strong>（所以可以用作 DOM 操作）</p> <h4 id="q-a-2"><a href="#q-a-2" class="header-anchor">#</a> Q&amp;A</h4> <h5 id="什么是副作用"><a href="#什么是副作用" class="header-anchor">#</a> 什么是副作用？</h5> <p>副作用的对立面是纯函数，纯函数的返回值只由入参决定。函数的行为不止依赖入参，且除了返回返回值之外还做了其他事情，这些事情就是副作用。</p> <p>例如：i++ 除了输出表达式的值，还修改了 i，就是副作用</p> <p>例如：在渲染阶段改变 dom、添加eventListener、设置定时器、记录日志等，这种要么改了除了入参之外的东西，要么是做了异步操作，组件生命周期无法捕获的，都算副作用</p> <h5 id="副作用如何清理"><a href="#副作用如何清理" class="header-anchor">#</a> 副作用如何清理？</h5> <p>useEffect 传的的 callback 返回的函数，在 fiber 的清理阶段会执行该函数，达到清理上一次 effect 的效果</p> <h5 id="为什么要写-deps-数组项"><a href="#为什么要写-deps-数组项" class="header-anchor">#</a> 为什么要写 deps 数组项？</h5> <ul><li>默认 effect 在每次渲染结束后执行，传入 deps 用于在 re-render 时判断是否重新执行 callback，所以 deps 必须要按照实际依赖传入，不能少传也不要多传！</li> <li>deps 的比较是浅比较，故而传入对象、函数进去毫无意义</li> <li>deps 数组必须是 mutable 的，比如不能也不必传 useRef、dispatch 等进去</li></ul> <h5 id="为什么要把-effect-中所有引用的值都手动声明到-deps-数组项中-不会自动生成吗"><a href="#为什么要把-effect-中所有引用的值都手动声明到-deps-数组项中-不会自动生成吗" class="header-anchor">#</a> 为什么要把 effect 中所有引用的值都手动声明到 deps 数组项中，不会自动生成吗？</h5> <p>主要是因为目前 react 还没有这么智能的编译功能，是个未来的方向。从概念上来说它表现为：所有 effect 函数中引用的值都应该出现在依赖项数组中</p> <h5 id="不写-deps-会有什么后果"><a href="#不写-deps-会有什么后果" class="header-anchor">#</a> 不写 deps 会有什么后果？</h5> <p>见如下代码，demo 希望利用 [] 依赖，将 useEffect 当做 didMount 使用，再结合 setInterval 达到每秒 count 的值自增 1 的效果</p> <div class="language-react extra-class"><pre class="language-text"><code>function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
      setCount(count + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
</code></pre></div><p>然而结果却是：1 1 1 ....</p> <p>因为 useEffect 形成了闭包环境，故而 setInterval 永远在第一次 render 的闭包里，故而 count 的值永远是 0，罪魁祸首就是<strong>没有对依赖诚实</strong>导致的，例子中 useEffect 明明依赖了 count，但是依赖项缺非要写 []，所以产生了难以理解的错误，唯一改正方法就是对依赖保持诚实</p> <blockquote><p>推荐启用 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks#installation" target="_blank" rel="noopener noreferrer"><code>eslint-plugin-react-hooks</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 中的 <a href="https://github.com/facebook/react/issues/14920" target="_blank" rel="noopener noreferrer"><code>exhaustive-deps</code><span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 规则。此规则会在添加错误依赖时发出警告并给出修复建议。</p></blockquote> <h6 id="如何不在每次-re-render-时重新实例化-setinterval"><a href="#如何不在每次-re-render-时重新实例化-setinterval" class="header-anchor">#</a> 如何不在每次 re-render 时重新实例化 setInterval？</h6> <p>最简单的方法是用 useState 的第二种赋值方法，用回调函数进行赋值</p> <div class="language-react extra-class"><pre class="language-text"><code>function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
      // 用回调函数进行赋值
      setCount(c =&gt; c + 1);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, []);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
</code></pre></div><p>该种写法做到了</p> <ul><li>不依赖 count，所以对依赖诚实</li> <li>依赖项为[]，故而初始化会对 setInterval 进行实例化</li></ul> <p>故而输出是正确的 1 2 3...，因为 setCount 的回调函数中，c 值永远指向最新的 count 值，故而没有逻辑漏洞，但是如果存在两个以上变量需要使用时，就会存在问题</p> <h6 id="同时使用两个以上变量时"><a href="#同时使用两个以上变量时" class="header-anchor">#</a> 同时使用两个以上变量时？</h6> <p>如果需要同时对 count 和 step 两个变量做累加时，那 useEffect 的依赖必然要写上其中某种值，故而频繁实例化的问题就又出现了</p> <div class="language-react extra-class"><pre class="language-text"><code>function Counter() {
  const [count, setCount] = useState(0);
  const [step, setStep] = useState(0);

  useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
      setCount(c =&gt; c + step);
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [step]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
</code></pre></div><p>由于 setCount 只能拿到最新的 count 的值，故而为了每次都能到最新的 step 的值，需要将 step 写到 useEffect 的依赖中，导致 setInterval 被频繁实例化，这就引出了 useReducer</p> <h3 id="usereducer"><a href="#usereducer" class="header-anchor">#</a> UseReducer</h3> <p>对上面 count + step 累加情况问题的解决如下：</p> <h4 id="api-示例-3"><a href="#api-示例-3" class="header-anchor">#</a> API 示例</h4> <div class="language-react extra-class"><pre class="language-text"><code>function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  const { count, step } = state;

  useEffect(() =&gt; {
    const id = setInterval(() =&gt; {
      dispatch({ type: &quot;tick&quot; });
    }, 1000);
    return () =&gt; clearInterval(id);
  }, [dispatch]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}

function reducer(state, action) {
  switch (action.type) {
    case &quot;tick&quot;:
      return {
        ...state,
        count: state.count + state.step
      };
  }
}
</code></pre></div><h4 id="应用场景-3"><a href="#应用场景-3" class="header-anchor">#</a> 应用场景</h4> <p>是 <code>useState</code> 的替代方案，当 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖前一个 state 的值等。另外使用 useReducer 还能给触发深更新的组件做性能优化，因为可以<strong>给子组件传递 dispatch 而不是回调函数</strong></p> <h4 id="q-a-3"><a href="#q-a-3" class="header-anchor">#</a> Q&amp;A</h4> <h5 id="对-dispatch-的依赖为什么不需要写在-deps-中"><a href="#对-dispatch-的依赖为什么不需要写在-deps-中" class="header-anchor">#</a> 对 dispatch 的依赖为什么不需要写在 deps 中？</h5> <p>如上例子也还是有个依赖的，那就是 dispatch，但是 dispatch 引用永远也不会变，故而可以忽略影响，这就体现了无论如何要对 deps 保持诚实</p> <h5 id="所有函数为什么都必须写在-useeffect-中"><a href="#所有函数为什么都必须写在-useeffect-中" class="header-anchor">#</a> 所有函数为什么都必须写在 useEffect 中？</h5> <p>如上例子引发一个注意项，为了避免遗漏依赖，必须将函数写在 useEffect 内部，这样  <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener noreferrer">eslint-plugin-react-hooks<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 才能通过静态分析补齐依赖项，这就引发了新问题，所有函数写在 useEffect 内部显得非常难以维护</p> <div class="language-react extra-class"><pre class="language-text"><code>function Counter() {
  const [count, setCount] = useState(0);

  useEffect(() =&gt; {
    // getFetchUrl 依赖了 count，如果将其定义在 useEffect 外部，则难以看出 useEffect 的依赖项包含 count
    function getFetchUrl() {
      return &quot;https://v?query=&quot; + count;
    }

    getFetchUrl();
  }, [count]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
</code></pre></div><h5 id="如何将函数抽到-useeffect-外部"><a href="#如何将函数抽到-useeffect-外部" class="header-anchor">#</a> 如何将函数抽到 useEffect 外部？</h5> <p>引出了一个新的 hook：<code>useCallback</code>，就是为了解决将函数抽到 useEffect 外部的问题</p> <h2 id="性能优化相关-hooks"><a href="#性能优化相关-hooks" class="header-anchor">#</a> 性能优化相关 Hooks</h2> <h3 id="usecallback"><a href="#usecallback" class="header-anchor">#</a> UseCallback</h3> <h4 id="api-示例-4"><a href="#api-示例-4" class="header-anchor">#</a> API 示例</h4> <div class="language-react extra-class"><pre class="language-text"><code>function Counter() {
  const [count, setCount] = useState(0);

  const getFetchUrl = useCallback(() =&gt; {
    return &quot;https://v?query=&quot; + count;
  }, [count]);

  useEffect(() =&gt; {
    getFetchUrl();
  }, [getFetchUrl]);

  return &lt;h1&gt;{count}&lt;/h1&gt;;
}
</code></pre></div><p>可以看到 useCallback 也有 deps 输入，将 getFetchUrl 函数的依赖项通过 useCallback 打包到 getFetchUrl 函数中，那么 useEffect 就只需要依赖 getFetchUrl 这个函数，实现了对 count 的间接依赖</p> <h4 id="应用场景-4"><a href="#应用场景-4" class="header-anchor">#</a> 应用场景</h4> <p>返回一个 memoized 的回调函数，本质是仅在 deps 数组项发生变化时才会重新执行函数变化引用</p> <p><code>useCallback(fn, deps)</code> 相当于 <code>useMemo(() =&gt; fn, deps)</code></p> <h4 id="q-a-4"><a href="#q-a-4" class="header-anchor">#</a> Q&amp;A</h4> <h5 id="为什么-usecallback-比-componentdidupdate-更好用"><a href="#为什么-usecallback-比-componentdidupdate-更好用" class="header-anchor">#</a> 为什么 useCallback 比 componentDidUpdate 更好用？</h5> <p>见如下例子，class 组件实现参数变化时重新执行函数</p> <div class="language-react extra-class"><pre class="language-text"><code>class Parent extends Component {
  state = {
    count: 0,
    step: 0
  };
  fetchData = () =&gt; {
    const url =
      &quot;https://v?query=&quot; + this.state.count + &quot;&amp;step=&quot; + this.state.step;
  };
  render() {
    return &lt;Child fetchData={this.fetchData} count={count} step={step} /&gt;;
  }
}

class Child extends Component {
  state = {
    data: null
  };
  componentDidMount() {
    this.props.fetchData();
  }
  componentDidUpdate(prevProps) {
    if (
      this.props.count !== prevProps.count &amp;&amp;
      this.props.step !== prevProps.step // 别漏了！
    ) {
      this.props.fetchData();
    }
  }
  render() {
    // ...
  }
}
</code></pre></div><p>父级的 fetchData 函数依赖 count 和 step 两个参数，child 中需要判断 count 和 step 变化后重新执行 fetchData 函数，那么存在严重的无法维护问题：</p> <ul><li>其他人在 child 中看到 fetchData 时怎么知道依赖了props.count 和 props.step 这两个参数？</li> <li>如果 fetchData 某天又加了一个新的参数依赖，那么下游所有 child 组件都需要更新对依赖参数的判断逻辑，否则新的参数变化时 child 中不会重新执行 fetchData</li></ul> <p>换成 function + useCallback 则会十分简单：</p> <div class="language-react extra-class"><pre class="language-text"><code>function Parent() {
  const [ count, setCount ] = useState(0);
  const [ step, setStep ] = useState(0);

  const fetchData = useCallback(() =&gt; {
    const url = 'https://v/search?query=' + count + &quot;&amp;step=&quot; + step;
  }, [count, step])

  return (
    &lt;Child fetchData={fetchData} /&gt;
  )
}

function Child(props) {
  useEffect(() =&gt; {
    props.fetchData()
  }, [props.fetchData])

  return (
    // ...
  )
}
</code></pre></div><p>当 fetchData 依赖更新后，<a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener noreferrer">eslint-plugin-react-hooks<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 会自动补上更新后的依赖，下游不需要关心 fetchData 函数依赖了什么参数，只需要关心依赖了 fetchData 这个函数即可</p> <h5 id="如何将函数抽离到整个组件的外部"><a href="#如何将函数抽离到整个组件的外部" class="header-anchor">#</a> 如何将函数抽离到整个组件的外部？</h5> <p>可以使用 useCallback 将函数抽离到 useEffect 外部，那如何将函数抽离到整个组件的外部？</p> <p>可以用自定义 Hooks 实现，如下，将上述例子的 fetchData 函数抽离到整个组件外部</p> <div class="language-react extra-class"><pre class="language-text"><code>function useFetch(count, step) {
  return useCallback(() =&gt; {
    const url = &quot;https://v/search?query=&quot; + count + &quot;&amp;step=&quot; + step;
  }, [count, step]);
}

function Parent() {
  const [count, setCount] = useState(0);
  const [step, setStep] = useState(0);
  const [other, setOther] = useState(0);
  const fetch = useFetch(count, step); // 封装了 useFetch

  useEffect(() =&gt; {
    fetch();
  }, [fetch]);

  return (
    &lt;div&gt;
      &lt;button onClick={() =&gt; setCount(c =&gt; c + 1)}&gt;setCount {count}&lt;/button&gt;
      &lt;button onClick={() =&gt; setStep(c =&gt; c + 1)}&gt;setStep {step}&lt;/button&gt;
      &lt;button onClick={() =&gt; setOther(c =&gt; c + 1)}&gt;setOther {other}&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre></div><p>观察可以发现，count 和 step 都会频繁变化，导致 useFetch 中 useCallback 依赖的变化，进而导致重新生成函数，然而这个函数没必要每次都重新生成，换个频繁切换的例子观察一下性能损耗有多大</p> <div class="language-react extra-class"><pre class="language-text"><code>function useDraggable(dom, count, step) {
  return useCallback(() =&gt; {
    // 上报日志
    report(count, step);

    // 对区域进行初始化，非常耗时
    // ... 省略耗时代码
  }, [dom, count, step]);
}

function Parent(props) {
  const [count, setCount] = useState(0);
  const [step, setStep] = useState(0);
  const [other, setOther] = useState(0);
  const drag = useDraggable(props.dom, count, step); // 封装了拖拽函数

  useEffect(() =&gt; {
    // dom 变化时重新实例化
    drag()
  }, [drag])
}
</code></pre></div><p>这种情况下函数依赖就特别不合理，依赖变化触发函数的重新执行，但只是为了上报一些日志而整体执行函数，十分耗时，得不偿失。所以可以利用 useRef 来保证耗时函数的依赖不变</p> <h3 id="useref"><a href="#useref" class="header-anchor">#</a> UseRef</h3> <h4 id="api-示例-5"><a href="#api-示例-5" class="header-anchor">#</a> API 示例</h4> <div class="language-react extra-class"><pre class="language-text"><code>function useFetch(count, step) {
  const countRef = useRef(count);
  const stepRef = useRef(step);

  useEffect(() =&gt; {
    countRef.current = count;
    stepRef.current = step;
  });

  return useCallback(() =&gt; {
    const url =
      &quot;https://v/search?query=&quot; + countRef.current + &quot;&amp;step=&quot; + stepRef.current;
  }, [countRef, stepRef]); // 依赖不会变，却能每次拿到最新的值
}
</code></pre></div><p>如上，useRef 的引用是不变的，故而函数不会每次都重新执行，但又能在函数中拿到 ref 的最新值，但这样对函数改动成本较高，故而有更通用的做法解决此类问题，那就是利用自定义 hooks 解决函数重新实例化问题</p> <h4 id="通用的自定义-hooks-解决函数重新实例化问题"><a href="#通用的自定义-hooks-解决函数重新实例化问题" class="header-anchor">#</a> 通用的自定义 Hooks 解决函数重新实例化问题</h4> <p>课利用 useRef 创造一个自定义 hook 代替 useCallback，使其 deps 变化时回调不会重新执行，但却能拿到最新值</p> <div class="language-react extra-class"><pre class="language-text"><code>function useEventCallback(fn, dependencies) {
  const ref = useRef(null);

  useEffect(() =&gt; {
    // fn 回调函数变化时，ref.current 指向最新的 fn
    ref.current = fn;
  }, [fn, ...deps]); // deps 变化时，也为 ref.current 重新赋值，此时 fn 内部的 deps 也是最新的

  return useCallback(() =&gt; {
    const fn = ref.current;
    return fn();
  }, [ref]); // 依赖不会变，所以每次都可以返回 deps 最新的 fn，且 fn 不会重新执行
}
</code></pre></div><p>以上代码还是利用了capture values 的概念，即每次渲染的闭包中，回调函数拿到的总是最新 render 闭包中的那个，所以 deps 的值永远是最新的，且函数不会被重新初始化</p> <h4 id="应用场景-5"><a href="#应用场景-5" class="header-anchor">#</a> 应用场景</h4> <ul><li>useRef 是所有 Hooks API 中唯一一个返回 mutable 数据的</li> <li>修改 useRef 值的唯一方法是修改其 current 的值，且值的变更不会引起 re-render</li> <li>每次组件 re-render 时 iseRef 都返回固定不变的值</li></ul> <h4 id="q-a-5"><a href="#q-a-5" class="header-anchor">#</a> Q&amp;A</h4> <h5 id="为什么-useref-是唯一一个返回-mutable-数据的-hook"><a href="#为什么-useref-是唯一一个返回-mutable-数据的-hook" class="header-anchor">#</a> 为什么 useRef 是唯一一个返回 mutable 数据的 hook？</h5> <ul><li>非 useRef 相关的 hooks api，本质都形成了闭包，闭包有自己独立的状态，这就是 capture values 的本质</li> <li>所有 hooks api 都具有 capture values 特性，除了 useRef
<ul><li>见如下代码（始终能拿到 state 最新值），state 是 immutable 的（setState 后一定会生成一个全新的 state 引用，故而每次<code>setTimeout</code>都读取了当前渲染闭包环境的数据，虽然新的值跟着最新的渲染变了，但旧的渲染中状态仍然是旧值），ref 是 mutable 的</li> <li>通过 useRef 创建的对象，其值只有一份，且在每次的 render 中都共享</li></ul></li></ul> <div class="language-react extra-class"><pre class="language-text"><code>function App() {
  const [count, setCount] = useState(0);
  const countRef = useRef(count);
  console.log('组件重新渲染', count);

  useEffect(() =&gt; {
    // 改变 useRef 的原始值
    countRef.current = count;

    setTimeout(() =&gt; {
      // setTimeout useRef.current 里边始终能拿到 state 最新值，快速点击 3 次执行结果为 3 3 3
      console.log(`current count is ${countRef.current}`);
      // setTimeout state 每次都读取了当前闭包环境的数据，快速点击 3 次执行结果为 1 2 3
      console.log(`current count is ${state}`);
    }, 3000);
  }, [count]);

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;Click me&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre></div><h3 id="usememo"><a href="#usememo" class="header-anchor">#</a> UseMemo</h3> <h4 id="api-示例-6"><a href="#api-示例-6" class="header-anchor">#</a> API 示例</h4> <h5 id="使用-usememo-做局部-purerender"><a href="#使用-usememo-做局部-purerender" class="header-anchor">#</a> 使用 useMemo 做局部 pureRender</h5> <p>用 useMemo 包裹渲染代码，这样就算 Child 因为 props 变动而 re-render 了，只要 useMemo 的 deps 中声明的参数 props.fetchData 经过浅对比后发现相等，就不会 re-render 渲染函数</p> <div class="language-react extra-class"><pre class="language-text"><code>const Child = (props) =&gt; {
  useEffect(() =&gt; {
    props.fetchData()
  }, [props.fetchData])

  return useMemo(() =&gt; (
    // ... 渲染代码
  ), [props.fetchData])
}
</code></pre></div><h4 id="应用场景-6"><a href="#应用场景-6" class="header-anchor">#</a> 应用场景</h4> <h5 id="memo-usecontext-做-function-组件间共享参数-函数"><a href="#memo-usecontext-做-function-组件间共享参数-函数" class="header-anchor">#</a> memo + useContext 做 function 组件间共享参数 / 函数</h5> <div class="language-react extra-class"><pre class="language-text"><code>// 这样就不需要在每个函数间进行参数透传了，公共函数可以都放在 Context 里
const Store = createContext(null);

function Parent() {
  const [count, setCount] = useState(0);
  const [step, setStep] = useState(0);
  const fetchData = useFetch(count, step);

  return (
    &lt;Store.Provider value={{ setCount, setStep, fetchData }}&gt;
      &lt;Child /&gt;
    &lt;/Store.Provider&gt;
  );
}

// 用 memo 包裹的组件在 re-render 时会对 props 进行浅对比，没有变化就不会触发重渲染
const Child = memo((props) =&gt; {
  const { setCount } = useContext(Store)

  function onClick() {
    setCount(count =&gt; count + 1)
  }

  return (
    // ...
  )
})
</code></pre></div><p>但当函数多了之后，provider 的 value 会非常臃肿，故而启用 useReducer 为 context 传递的内容进行瘦身</p> <div class="language-react extra-class"><pre class="language-text"><code>const Store = createContext(null);

// 所有回调函数都通过调用 dispatch 完成，则 provider 仅需传递 dispatch 一个函数
function Parent() {
  const [state, dispatch] = useReducer(reducer, { count: 0, step: 0 });

  return (
    &lt;Store.Provider value={dispatch}&gt;
      &lt;Child /&gt;
    &lt;/Store.Provider&gt;
  );
}

const Child = useMemo((props) =&gt; {
  const dispatch = useContext(Store)

  function onClick() {
    dispatch({
      type: 'countInc'
    })
  }

  return (
    // ...
  )
})

function reducer(state, action) {
  switch (action.type) {
    case &quot;tick&quot;:
      return {
        ...state,
        count: state.count + state.step
      };
  }
}
</code></pre></div><p>既然赋值的 dispatch 函数能共享，那么把 state 也放到 provider 的 value 里，赋值和读取岂不是变得更简单了？但 **state 放到 context 中会存在潜在性能问题！！ **</p> <div class="language-react extra-class"><pre class="language-text"><code>const Store = createContext(null);

function Parent() {
  const [state, dispatch] = useReducer(reducer, { count: 0, step: 0 });

  return (
    &lt;Store.Provider value={{ state, dispatch }}&gt;
      &lt;Count /&gt;
      &lt;Step /&gt;
    &lt;/Store.Provider&gt;
  );
}

const Count = memo(() =&gt; {
  const { state, dispatch } = useContext(Store);
  return (
    &lt;button onClick={() =&gt; dispatch(&quot;incCount&quot;)}&gt;incCount {state.count}&lt;/button&gt;
  );
});

const Step = memo(() =&gt; {
  const { state, dispatch } = useContext(Store);
  return (
    &lt;button onClick={() =&gt; dispatch(&quot;incStep&quot;)}&gt;incStep {state.step}&lt;/button&gt;
  );
});

function reducer(state, action) {
  switch (action.type) {
    case &quot;tick&quot;:
      return {
        ...state,
        count: state.count + state.step
      };
  }
}
</code></pre></div><p>出现的结果是无论点击 <code>incCount</code> 还是 <code>incStep</code>，都会同时触发两个组件的 re-render，其问题在于 memo 只能挡住最外层的 props 传入，但通过 useContext 注入在函数内部的数据，会绕过 memo</p> <p>当触发 dispatch 导致 state 的引用变化时，所有使用了 state 的组件都会触发 re-render，那么就需要用 useMemo 了</p> <h5 id="usememo-usecontext-做-function-组件间共享参数-函数"><a href="#usememo-usecontext-做-function-组件间共享参数-函数" class="header-anchor">#</a> useMemo + useContext 做 function 组件间共享参数 / 函数</h5> <p>如果组件使用了 useContext，且不使用 props，就可以完全使用 useMemo 来做性能优化</p> <div class="language-react extra-class"><pre class="language-text"><code>const Store = createContext(null);

function Parent() {
  const [state, dispatch] = useReducer(reducer, { count: 0, step: 0 });

  return (
    &lt;Store.Provider value={{ state, dispatch }}&gt;
      &lt;Count /&gt;
      &lt;Step /&gt;
    &lt;/Store.Provider&gt;
  );
}

const Count = () =&gt; {
  const { state, dispatch } = useContext(Store);
  return useMemo(
    () =&gt; (
      &lt;button onClick={() =&gt; dispatch(&quot;incCount&quot;)}&gt;
        incCount {state.count}
      &lt;/button&gt;
    ),
    [state.count, dispatch]
  );
};

const Step = () =&gt; {
  const { state, dispatch } = useContext(Store);
  return useMemo(
    () =&gt; (
      &lt;button onClick={() =&gt; dispatch(&quot;incStep&quot;)}&gt;incStep {state.step}&lt;/button&gt;
    ),
    [state.step, dispatch]
  );
};

function reducer(state, action) {
  switch (action.type) {
    case &quot;tick&quot;:
      return {
        ...state,
        count: state.count + state.step
      };
  }
}
</code></pre></div><blockquote><p>useMemo 类似 redux 的 connect</p></blockquote> <h4 id="q-a-6"><a href="#q-a-6" class="header-anchor">#</a> Q&amp;A</h4> <h5 id="usememo-和-memo-有什么区别"><a href="#usememo-和-memo-有什么区别" class="header-anchor">#</a> useMemo 和 memo 有什么区别</h5> <ul><li>memo 包裹的函数会对 props 的每一项进行浅对比，没有变化就不会触发组件的 re-render</li> <li>useMemo(() =&gt; {}, []) 可以结合 <a href="https://www.npmjs.com/package/eslint-plugin-react-hooks" target="_blank" rel="noopener noreferrer">eslint-plugin-react-hooks<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>  实现更细粒度的性能优化，可指定个别 props 参数作为 deps，deps 没有变化就不会触发函数的 re-render</li></ul> <h2 id="其他-hooks-api"><a href="#其他-hooks-api" class="header-anchor">#</a> 其他 Hooks API</h2> <h3 id="uselayouteffect"><a href="#uselayouteffect" class="header-anchor">#</a> UseLayoutEffect</h3> <p>和 useEffect 一致，区别只有执行时机，是在 dom 绘制之前执行的（和 <code>componentDidMount</code>、<code>componentDidUpdate</code>执行时机相同）</p> <h3 id="usedebugvalue"><a href="#usedebugvalue" class="header-anchor">#</a> UseDebugValue</h3> <p>用于开发者工具调试</p> <h3 id="useimperativehandle"><a href="#useimperativehandle" class="header-anchor">#</a> UseImperativeHandle</h3> <p>配合 forwardRef 使用，用于自定义通过 ref 给父组件暴露的值</p> <h2 id="自定义-hook"><a href="#自定义-hook" class="header-anchor">#</a> 自定义 Hook</h2> <p>只要函数名遵循以 <code>use</code>开头，且返回非 JSX 元素，就可以创建自定义的 hooks。自定义 hooks 内还可以调用包括内置 hooks 在内的所有自定义 hooks，如下：</p> <div class="language-react extra-class"><pre class="language-text"><code>function useCurrentValue(value) {
  const ref = useRef(0)l
  useEffect(() =&gt; {
    ref.current = value;
  }, [value]);
  
  return ref;
}

function Counter() {
  const [count, setCount] = useState(0);
  const currentCount = useCurrentValue(count);

  const log = () =&gt; {
    setCount(count + 1);
    setTimeout(() =&gt; {
      console.log(currentCount.current);
    }, 3000);
  };

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={log}&gt;Click me&lt;/button&gt;
    &lt;/div&gt;
  );
}
</code></pre></div><h4 id="自定义-hook-处理副作用"><a href="#自定义-hook-处理副作用" class="header-anchor">#</a> 自定义 Hook 处理副作用</h4> <p>举例：异步从接口里获取数据，最佳的做法是封装成一个自定义 hook</p> <div class="language-react extra-class"><pre class="language-text"><code>const useDataApi&lt;T&gt; = (initialUrl: string, initialData: T) =&gt; {
  const [url, setUrl] = useState(initialUrl);

  const [state, dispatch] = useReducer(dataFetchReducer, {
    isLoading: false,
    isError: false,
    data: initialData
  });

  useEffect(() =&gt; {
    let didCancel = false;

    const fetchData = async () =&gt; {
      dispatch({ type: &quot;FETCH_INIT&quot; });

      try {
        const result = await axios(url);
        if (!didCancel) {
          dispatch({ type: &quot;FETCH_SUCCESS&quot;, payload: result.data });
        }
      } catch (error) {
        if (!didCancel) {
          dispatch({ type: &quot;FETCH_FAILURE&quot; });
        }
      }
    };

    fetchData();

    return () =&gt; {
      didCancel = true;
    };
  }, [url]);

  const doFetch = url =&gt; setUrl(url);

  return { ...state, doFetch };
};
</code></pre></div><p>可以看到，自定义 Hook 拥有完整生命周期，我们可以将取数过程封装起来，只暴露状态</p> <ul><li>是否在加载中：<code>isLoading</code></li> <li>是否取数失败：<code>isError</code></li> <li>数据：<code>data</code></li></ul> <p>在组件中使用非常方便</p> <div class="language-react extra-class"><pre class="language-text"><code>function App() {
  const { data, isLoading, isError } = useDataApi(&quot;https://v&quot;, {
    showLog: true
  });
}
</code></pre></div><p>如果这个值需要存储到数据流，在所有组件之间共享，可以结合 useEffect 和 useReducer</p> <div class="language-react extra-class"><pre class="language-text"><code>function App(props) {
  const { dispatch } = useContext(Store);

  const { data, isLoading, isError } = useDataApi(&quot;https://v&quot;, {
    showLog: true
  });

  useEffect(() =&gt; {
    dispatch({
      type: &quot;updateLoading&quot;,
      data,
      isLoading,
      isError
    });
  }, [dispatch, data, isLoading, isError]);
}
</code></pre></div><h2 id="function-组件的-defaultprops"><a href="#function-组件的-defaultprops" class="header-anchor">#</a> Function 组件的 defaultProps</h2> <p>先举个例子，用 es6 特性给参数定义阶段赋值</p> <div class="language-react extra-class"><pre class="language-text"><code>// 每次父组件刷新时，Child 组件跟着刷新，看起来 log 只会打印一次，实际每次渲染都会打印 log，证明 type 每次的引用都是不同的
const Child = memo(({ type = { a: 1 } }) =&gt; {
  useEffect(() =&gt; {
    console.log(&quot;type&quot;, type);
  }, [type]);

  return &lt;div&gt;Child&lt;/div&gt;;
});
</code></pre></div><p>这种方法看似优雅，实际有个重大隐患：没有命中的 props 每次渲染引用都不同</p> <h3 id="使用-react-内置方案"><a href="#使用-react-内置方案" class="header-anchor">#</a> 使用 React 内置方案</h3> <div class="language-react extra-class"><pre class="language-text"><code>// 不断刷新父组件，只会打印一次 log
const Child = ({ type }) =&gt; {
  useEffect(() =&gt; {
    console.log(&quot;type&quot;, type);
  }, [type]);

  return &lt;div&gt;Child&lt;/div&gt;;
};

Child.defaultProps = {
  type: { a: 1 }
};
</code></pre></div><p>建议使用 react 的内置方案，因为纯函数的方案不利于保持引用不变</p> <h2 id="注意事项-2"><a href="#注意事项-2" class="header-anchor">#</a> 注意事项</h2> <h3 id="父组件传对象给子组件导致的问题"><a href="#父组件传对象给子组件导致的问题" class="header-anchor">#</a> 父组件传对象给子组件导致的问题</h3> <div class="language-react extra-class"><pre class="language-text"><code>// 做一个点击累加的按钮作为父组件，那么父组件每次点击后都会刷新
function Parent() {
  const [count, forceUpdate] = useState(0);

  const schema = { b: 1 };

  return (
    &lt;div&gt;
      &lt;Child schema={schema} /&gt;
      &lt;div onClick={() =&gt; forceUpdate(count + 1)}&gt;Count {count}&lt;/div&gt;
    &lt;/div&gt;
  );
}

const Child = memo(props =&gt; {
  useEffect(() =&gt; {
    console.log(&quot;schema&quot;, props.schema);
  // props.schema 声明失效
  }, [props.schema]);

  return &lt;div&gt;Child&lt;/div&gt;;
});
</code></pre></div><p>我们希望只有当 props.schema 变化就会触发 child 组件打印 log，但实际每次父组件刷新时 Child 就会打印 log，即 [props.schema] 完全失效，因为每次刷新后，props.schema 的值虽然不变，但引用都在变，而 hook 函数的 deps 是浅对比</p> <p>解法一：改写子组件的依赖</p> <div class="language-react extra-class"><pre class="language-text"><code>const Child = memo(props =&gt; {
  useEffect(() =&gt; {
    console.log(&quot;schema&quot;, props.schema);
  // props.schema 声明失效
  }, [JSON.stringfy(props.schema)]);

  return &lt;div&gt;Child&lt;/div&gt;;
});
</code></pre></div><p>解法二：ref 优化父组件传值</p> <div class="language-react extra-class"><pre class="language-text"><code>function Parent() {
  const [count, forceUpdate] = useState(0);

  const schema = useRef({ b: 1 });

  return (
    &lt;div&gt;
      &lt;Child schema={schema.current} /&gt;
      &lt;div onClick={() =&gt; forceUpdate(count + 1)}&gt;Count {count}&lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">12/2/2021, 11:53:33 AM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/technology/front-end/phaser3.html" class="prev"><i aria-label="icon: left" class="anticon anticon-left"><svg viewBox="64 64 896 896" focusable="false" data-icon="left" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M724 218.3V141c0-6.7-7.7-10.4-12.9-6.3L260.3 486.8a31.86 31.86 0 0 0 0 50.3l450.8 352.1c5.3 4.1 12.9.4 12.9-6.3v-77.3c0-4.9-2.3-9.6-6.1-12.6l-360-281 360-281.1c3.8-3 6.1-7.7 6.1-12.6z"></path></svg></i>
        Phaser 3
      </a></span> <span class="next"><a href="/technology/front-end/rxjs-operator.html">
        RxJs 操作符
        <i aria-label="icon: right" class="anticon anticon-right"><svg viewBox="64 64 896 896" focusable="false" data-icon="right" width="1em" height="1em" fill="currentColor" aria-hidden="true"><path d="M765.7 486.8L314.9 134.7A7.97 7.97 0 0 0 302 141v77.3c0 4.9 2.3 9.6 6.1 12.6l360 281.1-360 281.1c-3.9 3-6.1 7.7-6.1 12.6V883c0 6.7 7.7 10.4 12.9 6.3l450.8-352.1a31.96 31.96 0 0 0 0-50.4z"></path></svg></i></a></span></p></div> </main> <!----></div><div class="global-ui"><!----></div></div>
    <script src="/assets/js/app.f6cea7aa.js" defer></script><script src="/assets/js/2.d7b159a0.js" defer></script><script src="/assets/js/13.a8053161.js" defer></script>
  </body>
</html>