(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{786:function(t,e,n){"use strict";n.r(e);var s=n(76),a=Object(s.a)({},(function(){var t=this,e=t.$createElement,n=t._self._c||e;return n("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[n("h1",{attrs:{id:"react-hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#react-hook"}},[t._v("#")]),t._v(" React Hook")]),t._v(" "),n("h2",{attrs:{id:"function-vs-class"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-vs-class"}},[t._v("#")]),t._v(" Function Vs Class")]),t._v(" "),n("h3",{attrs:{id:"class-组件的缺陷"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#class-组件的缺陷"}},[t._v("#")]),t._v(" Class 组件的缺陷")]),t._v(" "),n("ol",[n("li",[t._v("this 的指向"),n("br"),n("img",{staticStyle:{zoom:"50%"},attrs:{src:"https://img-pub.fbcontent.cn/1634788362091_vlneswhzs.png"}})]),t._v(" "),n("li",[t._v("编译后的可读性差且性能不好\n"),n("ol",[n("li",[t._v("js 本身实现的类比较鸡肋")]),t._v(" "),n("li",[t._v("class 组件在 react 内部实际还是当做 Function 类来处理的")])])])]),t._v(" "),n("h3",{attrs:{id:"function-组件的缺陷"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-组件的缺陷"}},[t._v("#")]),t._v(" Function 组件的缺陷")]),t._v(" "),n("ol",[n("li",[t._v("function 本身无状态无存储，依赖 props 传入来响应变更，故而最外层还是得依赖一个 class component")])]),t._v(" "),n("h3",{attrs:{id:"function-hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-hook"}},[t._v("#")]),t._v(" Function + hook")]),t._v(" "),n("p",[t._v("要解决 function 的缺陷，关键在于让 function 组件自身具备状态处理的能力，即组件首次 render 后，能够通过某种机制再次触发自身状态变更，实现 re-render，即 hooks")]),t._v(" "),n("p",[t._v("hooks 诞生的原因就是为了便于静态分析依赖，简化 immutable 数据流的使用成本")]),t._v(" "),n("h2",{attrs:{id:"hooks-的实现和使用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#hooks-的实现和使用"}},[t._v("#")]),t._v(" Hooks 的实现和使用")]),t._v(" "),n("h3",{attrs:{id:"介绍"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#介绍"}},[t._v("#")]),t._v(" 介绍")]),t._v(" "),n("h4",{attrs:{id:"fiber-是什么"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#fiber-是什么"}},[t._v("#")]),t._v(" Fiber 是什么？")]),t._v(" "),n("p",[t._v("Fiber 是 react16 中的协调引擎，主要目的是使 virtual dom 可以进行增量式渲染")]),t._v(" "),n("h4",{attrs:{id:"注意事项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意事项"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),n("ul",[n("li",[t._v("只能在 function 组件中使用 hook")]),t._v(" "),n("li",[t._v("必须在函数组件顶部作用域调用 hooks api\n"),n("ul",[n("li",[t._v("state 是一个对象，对应 "),n("code",[t._v("FiberNode")]),t._v(" 中的 "),n("code",[t._v("memoizedState")]),t._v("属性，在 class 组件中调用 "),n("code",[t._v("setState()")]),t._v("时等同于更新 "),n("code",[t._v("memoizedState")]),t._v("，但在 functino 组件中， "),n("code",[t._v("memoizedState")]),t._v("被设计成一个链表。首次 render 后，react 就初始化了一个 Fiber 链表结构，之后只能通过"),n("code",[t._v("useState")]),t._v("这个 hook 返回的 dispatch 修改对应 FiberNode"),n("code",[t._v("的")]),t._v("memoizedState，因此必须要保证 hooks 顺序不变（对应链表的结点不变，才能修改作用到正确的链表结点上），故而只有放在顶层调用才能保证各个 hooks 的执行顺序")])])])]),t._v(" "),n("h3",{attrs:{id:"usecontext"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecontext"}},[t._v("#")]),t._v(" UseContext")]),t._v(" "),n("h4",{attrs:{id:"api-示例"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api-示例"}},[t._v("#")]),t._v(" API 示例")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const themes = {\n  light: {\n    foreground: "#000000",\n    background: "#eeeeee"\n  },\n  dark: {\n    foreground: "#ffffff",\n    background: "#222222"\n  }\n};\n\n// 提供默认值 themes.light\nconst ThemeContext = React.createContext(themes.light);\n\nfunction App() {\n  return (\n    <ThemeContext.Provider value={themes.dark}>\n      <Toolbar />\n    </ThemeContext.Provider>\n  );\n}\n\nfunction Toolbar(props) {\n  return (\n    <div>\n      <ThemedButton />\n    </div>\n  );\n}\n\nfunction ThemedButton() {\n  // 获取最近父元素上 provider 上获取的值，这里为 dark\n  const theme = useContext(ThemeContext);\n  return (\n    <button style={{ background: theme.background, color: theme.foreground }}>\n      I am styled by theme context!\n    </button>\n  );\n}\n')])])]),n("h4",{attrs:{id:"应用场景"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用场景"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),n("p",[t._v("方便组件之间状态共享，不用再层层传递")]),t._v(" "),n("h4",{attrs:{id:"q-a"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q-a"}},[t._v("#")]),t._v(" Q&A")]),t._v(" "),n("h5",{attrs:{id:"状态管理方案如何选取-context-是否可以代替-redux"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#状态管理方案如何选取-context-是否可以代替-redux"}},[t._v("#")]),t._v(" 状态管理方案如何选取？context 是否可以代替 redux？")]),t._v(" "),n("h3",{attrs:{id:"useeffect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useeffect"}},[t._v("#")]),t._v(" UseEffect")]),t._v(" "),n("h4",{attrs:{id:"api-示例-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api-示例-2"}},[t._v("#")]),t._v(" API 示例")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("useEffect(() => {\n  const subscription = props.source.subscribe();\n  return () => {\n    subscription.unsubscribe();\n  }\n  // effect 的 deps 数组项，发生变化时才会触发重新创建\n}, [props.source]);\n")])])]),n("p",[t._v("需要在[]中声明所有在外部作用域中发生变化且在 effect 中使用到的变量，否则就会引用到先前渲染中的旧变量")]),t._v(" "),n("h4",{attrs:{id:"应用场景-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-2"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),n("p",[t._v("处理 function 组件中的副作用，如异步操作、延迟操作等，可以替代 class 组件的 "),n("code",[t._v("componentDidMount")]),t._v("、"),n("code",[t._v("componentDidUpdate")]),t._v("、"),n("code",[t._v("componentWillUnmount")]),t._v(" 等生命周期，发生在"),n("strong",[t._v("组件被渲染为真实 DOM 后执行")]),t._v("（所以可以用作 DOM 操作）")]),t._v(" "),n("h4",{attrs:{id:"q-a-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q-a-2"}},[t._v("#")]),t._v(" Q&A")]),t._v(" "),n("h5",{attrs:{id:"什么是副作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是副作用"}},[t._v("#")]),t._v(" 什么是副作用？")]),t._v(" "),n("p",[t._v("副作用的对立面是纯函数，纯函数的返回值只由入参决定。函数的行为不止依赖入参，且除了返回返回值之外还做了其他事情，这些事情就是副作用。")]),t._v(" "),n("p",[t._v("例如：i++ 除了输出表达式的值，还修改了 i，就是副作用")]),t._v(" "),n("p",[t._v("例如：在渲染阶段改变 dom、添加eventListener、设置定时器、记录日志等，这种要么改了除了入参之外的东西，要么是做了异步操作，组件生命周期无法捕获的，都算副作用")]),t._v(" "),n("h5",{attrs:{id:"副作用如何清理"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#副作用如何清理"}},[t._v("#")]),t._v(" 副作用如何清理？")]),t._v(" "),n("p",[t._v("useEffect 传的的 callback 返回的函数，在 fiber 的清理阶段会执行该函数，达到清理上一次 effect 的效果")]),t._v(" "),n("h5",{attrs:{id:"为什么要写-deps-数组项"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么要写-deps-数组项"}},[t._v("#")]),t._v(" 为什么要写 deps 数组项？")]),t._v(" "),n("ul",[n("li",[t._v("默认 effect 在每次渲染结束后执行，传入 deps 用于在 re-render 时判断是否重新执行 callback，所以 deps 必须要按照实际依赖传入，不能少传也不要多传！")]),t._v(" "),n("li",[t._v("deps 的比较是浅比较，故而传入对象、函数进去毫无意义")]),t._v(" "),n("li",[t._v("deps 数组必须是 mutable 的，比如不能也不必传 useRef、dispatch 等进去")])]),t._v(" "),n("h5",{attrs:{id:"为什么要把-effect-中所有引用的值都手动声明到-deps-数组项中-不会自动生成吗"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么要把-effect-中所有引用的值都手动声明到-deps-数组项中-不会自动生成吗"}},[t._v("#")]),t._v(" 为什么要把 effect 中所有引用的值都手动声明到 deps 数组项中，不会自动生成吗？")]),t._v(" "),n("p",[t._v("主要是因为目前 react 还没有这么智能的编译功能，是个未来的方向。从概念上来说它表现为：所有 effect 函数中引用的值都应该出现在依赖项数组中")]),t._v(" "),n("h5",{attrs:{id:"不写-deps-会有什么后果"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#不写-deps-会有什么后果"}},[t._v("#")]),t._v(" 不写 deps 会有什么后果？")]),t._v(" "),n("p",[t._v("见如下代码，demo 希望利用 [] 依赖，将 useEffect 当做 didMount 使用，再结合 setInterval 达到每秒 count 的值自增 1 的效果")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(count + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  return <h1>{count}</h1>;\n}\n")])])]),n("p",[t._v("然而结果却是：1 1 1 ....")]),t._v(" "),n("p",[t._v("因为 useEffect 形成了闭包环境，故而 setInterval 永远在第一次 render 的闭包里，故而 count 的值永远是 0，罪魁祸首就是"),n("strong",[t._v("没有对依赖诚实")]),t._v("导致的，例子中 useEffect 明明依赖了 count，但是依赖项缺非要写 []，所以产生了难以理解的错误，唯一改正方法就是对依赖保持诚实")]),t._v(" "),n("blockquote",[n("p",[t._v("推荐启用 "),n("a",{attrs:{href:"https://www.npmjs.com/package/eslint-plugin-react-hooks#installation",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("eslint-plugin-react-hooks")]),n("OutboundLink")],1),t._v(" 中的 "),n("a",{attrs:{href:"https://github.com/facebook/react/issues/14920",target:"_blank",rel:"noopener noreferrer"}},[n("code",[t._v("exhaustive-deps")]),n("OutboundLink")],1),t._v(" 规则。此规则会在添加错误依赖时发出警告并给出修复建议。")])]),t._v(" "),n("h6",{attrs:{id:"如何不在每次-re-render-时重新实例化-setinterval"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何不在每次-re-render-时重新实例化-setinterval"}},[t._v("#")]),t._v(" 如何不在每次 re-render 时重新实例化 setInterval？")]),t._v(" "),n("p",[t._v("最简单的方法是用 useState 的第二种赋值方法，用回调函数进行赋值")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      // 用回调函数进行赋值\n      setCount(c => c + 1);\n    }, 1000);\n    return () => clearInterval(id);\n  }, []);\n\n  return <h1>{count}</h1>;\n}\n")])])]),n("p",[t._v("该种写法做到了")]),t._v(" "),n("ul",[n("li",[t._v("不依赖 count，所以对依赖诚实")]),t._v(" "),n("li",[t._v("依赖项为[]，故而初始化会对 setInterval 进行实例化")])]),t._v(" "),n("p",[t._v("故而输出是正确的 1 2 3...，因为 setCount 的回调函数中，c 值永远指向最新的 count 值，故而没有逻辑漏洞，但是如果存在两个以上变量需要使用时，就会存在问题")]),t._v(" "),n("h6",{attrs:{id:"同时使用两个以上变量时"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#同时使用两个以上变量时"}},[t._v("#")]),t._v(" 同时使用两个以上变量时？")]),t._v(" "),n("p",[t._v("如果需要同时对 count 和 step 两个变量做累加时，那 useEffect 的依赖必然要写上其中某种值，故而频繁实例化的问题就又出现了")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Counter() {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(0);\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      setCount(c => c + step);\n    }, 1000);\n    return () => clearInterval(id);\n  }, [step]);\n\n  return <h1>{count}</h1>;\n}\n")])])]),n("p",[t._v("由于 setCount 只能拿到最新的 count 的值，故而为了每次都能到最新的 step 的值，需要将 step 写到 useEffect 的依赖中，导致 setInterval 被频繁实例化，这就引出了 useReducer")]),t._v(" "),n("h3",{attrs:{id:"usereducer"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usereducer"}},[t._v("#")]),t._v(" UseReducer")]),t._v(" "),n("p",[t._v("对上面 count + step 累加情况问题的解决如下：")]),t._v(" "),n("h4",{attrs:{id:"api-示例-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api-示例-3"}},[t._v("#")]),t._v(" API 示例")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function Counter() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n  const { count, step } = state;\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      dispatch({ type: "tick" });\n    }, 1000);\n    return () => clearInterval(id);\n  }, [dispatch]);\n\n  return <h1>{count}</h1>;\n}\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case "tick":\n      return {\n        ...state,\n        count: state.count + state.step\n      };\n  }\n}\n')])])]),n("h4",{attrs:{id:"应用场景-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-3"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),n("p",[t._v("是 "),n("code",[t._v("useState")]),t._v(" 的替代方案，当 state 逻辑较复杂且包含多个子值，或者下一个 state 依赖前一个 state 的值等。另外使用 useReducer 还能给触发深更新的组件做性能优化，因为可以"),n("strong",[t._v("给子组件传递 dispatch 而不是回调函数")])]),t._v(" "),n("h4",{attrs:{id:"q-a-3"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q-a-3"}},[t._v("#")]),t._v(" Q&A")]),t._v(" "),n("h5",{attrs:{id:"对-dispatch-的依赖为什么不需要写在-deps-中"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#对-dispatch-的依赖为什么不需要写在-deps-中"}},[t._v("#")]),t._v(" 对 dispatch 的依赖为什么不需要写在 deps 中？")]),t._v(" "),n("p",[t._v("如上例子也还是有个依赖的，那就是 dispatch，但是 dispatch 引用永远也不会变，故而可以忽略影响，这就体现了无论如何要对 deps 保持诚实")]),t._v(" "),n("h5",{attrs:{id:"所有函数为什么都必须写在-useeffect-中"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#所有函数为什么都必须写在-useeffect-中"}},[t._v("#")]),t._v(" 所有函数为什么都必须写在 useEffect 中？")]),t._v(" "),n("p",[t._v("如上例子引发一个注意项，为了避免遗漏依赖，必须将函数写在 useEffect 内部，这样  "),n("a",{attrs:{href:"https://www.npmjs.com/package/eslint-plugin-react-hooks",target:"_blank",rel:"noopener noreferrer"}},[t._v("eslint-plugin-react-hooks"),n("OutboundLink")],1),t._v(" 才能通过静态分析补齐依赖项，这就引发了新问题，所有函数写在 useEffect 内部显得非常难以维护")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function Counter() {\n  const [count, setCount] = useState(0);\n\n  useEffect(() => {\n    // getFetchUrl 依赖了 count，如果将其定义在 useEffect 外部，则难以看出 useEffect 的依赖项包含 count\n    function getFetchUrl() {\n      return "https://v?query=" + count;\n    }\n\n    getFetchUrl();\n  }, [count]);\n\n  return <h1>{count}</h1>;\n}\n')])])]),n("h5",{attrs:{id:"如何将函数抽到-useeffect-外部"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何将函数抽到-useeffect-外部"}},[t._v("#")]),t._v(" 如何将函数抽到 useEffect 外部？")]),t._v(" "),n("p",[t._v("引出了一个新的 hook："),n("code",[t._v("useCallback")]),t._v("，就是为了解决将函数抽到 useEffect 外部的问题")]),t._v(" "),n("h2",{attrs:{id:"性能优化相关-hooks"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#性能优化相关-hooks"}},[t._v("#")]),t._v(" 性能优化相关 Hooks")]),t._v(" "),n("h3",{attrs:{id:"usecallback"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usecallback"}},[t._v("#")]),t._v(" UseCallback")]),t._v(" "),n("h4",{attrs:{id:"api-示例-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api-示例-4"}},[t._v("#")]),t._v(" API 示例")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function Counter() {\n  const [count, setCount] = useState(0);\n\n  const getFetchUrl = useCallback(() => {\n    return "https://v?query=" + count;\n  }, [count]);\n\n  useEffect(() => {\n    getFetchUrl();\n  }, [getFetchUrl]);\n\n  return <h1>{count}</h1>;\n}\n')])])]),n("p",[t._v("可以看到 useCallback 也有 deps 输入，将 getFetchUrl 函数的依赖项通过 useCallback 打包到 getFetchUrl 函数中，那么 useEffect 就只需要依赖 getFetchUrl 这个函数，实现了对 count 的间接依赖")]),t._v(" "),n("h4",{attrs:{id:"应用场景-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-4"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),n("p",[t._v("返回一个 memoized 的回调函数，本质是仅在 deps 数组项发生变化时才会重新执行函数变化引用")]),t._v(" "),n("p",[n("code",[t._v("useCallback(fn, deps)")]),t._v(" 相当于 "),n("code",[t._v("useMemo(() => fn, deps)")])]),t._v(" "),n("h4",{attrs:{id:"q-a-4"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q-a-4"}},[t._v("#")]),t._v(" Q&A")]),t._v(" "),n("h5",{attrs:{id:"为什么-usecallback-比-componentdidupdate-更好用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么-usecallback-比-componentdidupdate-更好用"}},[t._v("#")]),t._v(" 为什么 useCallback 比 componentDidUpdate 更好用？")]),t._v(" "),n("p",[t._v("见如下例子，class 组件实现参数变化时重新执行函数")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('class Parent extends Component {\n  state = {\n    count: 0,\n    step: 0\n  };\n  fetchData = () => {\n    const url =\n      "https://v?query=" + this.state.count + "&step=" + this.state.step;\n  };\n  render() {\n    return <Child fetchData={this.fetchData} count={count} step={step} />;\n  }\n}\n\nclass Child extends Component {\n  state = {\n    data: null\n  };\n  componentDidMount() {\n    this.props.fetchData();\n  }\n  componentDidUpdate(prevProps) {\n    if (\n      this.props.count !== prevProps.count &&\n      this.props.step !== prevProps.step // 别漏了！\n    ) {\n      this.props.fetchData();\n    }\n  }\n  render() {\n    // ...\n  }\n}\n')])])]),n("p",[t._v("父级的 fetchData 函数依赖 count 和 step 两个参数，child 中需要判断 count 和 step 变化后重新执行 fetchData 函数，那么存在严重的无法维护问题：")]),t._v(" "),n("ul",[n("li",[t._v("其他人在 child 中看到 fetchData 时怎么知道依赖了props.count 和 props.step 这两个参数？")]),t._v(" "),n("li",[t._v("如果 fetchData 某天又加了一个新的参数依赖，那么下游所有 child 组件都需要更新对依赖参数的判断逻辑，否则新的参数变化时 child 中不会重新执行 fetchData")])]),t._v(" "),n("p",[t._v("换成 function + useCallback 则会十分简单：")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Parent() {\n  const [ count, setCount ] = useState(0);\n  const [ step, setStep ] = useState(0);\n\n  const fetchData = useCallback(() => {\n    const url = 'https://v/search?query=' + count + \"&step=\" + step;\n  }, [count, step])\n\n  return (\n    <Child fetchData={fetchData} />\n  )\n}\n\nfunction Child(props) {\n  useEffect(() => {\n    props.fetchData()\n  }, [props.fetchData])\n\n  return (\n    // ...\n  )\n}\n")])])]),n("p",[t._v("当 fetchData 依赖更新后，"),n("a",{attrs:{href:"https://www.npmjs.com/package/eslint-plugin-react-hooks",target:"_blank",rel:"noopener noreferrer"}},[t._v("eslint-plugin-react-hooks"),n("OutboundLink")],1),t._v(" 会自动补上更新后的依赖，下游不需要关心 fetchData 函数依赖了什么参数，只需要关心依赖了 fetchData 这个函数即可")]),t._v(" "),n("h5",{attrs:{id:"如何将函数抽离到整个组件的外部"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#如何将函数抽离到整个组件的外部"}},[t._v("#")]),t._v(" 如何将函数抽离到整个组件的外部？")]),t._v(" "),n("p",[t._v("可以使用 useCallback 将函数抽离到 useEffect 外部，那如何将函数抽离到整个组件的外部？")]),t._v(" "),n("p",[t._v("可以用自定义 Hooks 实现，如下，将上述例子的 fetchData 函数抽离到整个组件外部")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function useFetch(count, step) {\n  return useCallback(() => {\n    const url = "https://v/search?query=" + count + "&step=" + step;\n  }, [count, step]);\n}\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(0);\n  const [other, setOther] = useState(0);\n  const fetch = useFetch(count, step); // 封装了 useFetch\n\n  useEffect(() => {\n    fetch();\n  }, [fetch]);\n\n  return (\n    <div>\n      <button onClick={() => setCount(c => c + 1)}>setCount {count}</button>\n      <button onClick={() => setStep(c => c + 1)}>setStep {step}</button>\n      <button onClick={() => setOther(c => c + 1)}>setOther {other}</button>\n    </div>\n  );\n}\n')])])]),n("p",[t._v("观察可以发现，count 和 step 都会频繁变化，导致 useFetch 中 useCallback 依赖的变化，进而导致重新生成函数，然而这个函数没必要每次都重新生成，换个频繁切换的例子观察一下性能损耗有多大")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function useDraggable(dom, count, step) {\n  return useCallback(() => {\n    // 上报日志\n    report(count, step);\n\n    // 对区域进行初始化，非常耗时\n    // ... 省略耗时代码\n  }, [dom, count, step]);\n}\n\nfunction Parent(props) {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(0);\n  const [other, setOther] = useState(0);\n  const drag = useDraggable(props.dom, count, step); // 封装了拖拽函数\n\n  useEffect(() => {\n    // dom 变化时重新实例化\n    drag()\n  }, [drag])\n}\n")])])]),n("p",[t._v("这种情况下函数依赖就特别不合理，依赖变化触发函数的重新执行，但只是为了上报一些日志而整体执行函数，十分耗时，得不偿失。所以可以利用 useRef 来保证耗时函数的依赖不变")]),t._v(" "),n("h3",{attrs:{id:"useref"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useref"}},[t._v("#")]),t._v(" UseRef")]),t._v(" "),n("h4",{attrs:{id:"api-示例-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api-示例-5"}},[t._v("#")]),t._v(" API 示例")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function useFetch(count, step) {\n  const countRef = useRef(count);\n  const stepRef = useRef(step);\n\n  useEffect(() => {\n    countRef.current = count;\n    stepRef.current = step;\n  });\n\n  return useCallback(() => {\n    const url =\n      "https://v/search?query=" + countRef.current + "&step=" + stepRef.current;\n  }, [countRef, stepRef]); // 依赖不会变，却能每次拿到最新的值\n}\n')])])]),n("p",[t._v("如上，useRef 的引用是不变的，故而函数不会每次都重新执行，但又能在函数中拿到 ref 的最新值，但这样对函数改动成本较高，故而有更通用的做法解决此类问题，那就是利用自定义 hooks 解决函数重新实例化问题")]),t._v(" "),n("h4",{attrs:{id:"通用的自定义-hooks-解决函数重新实例化问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#通用的自定义-hooks-解决函数重新实例化问题"}},[t._v("#")]),t._v(" 通用的自定义 Hooks 解决函数重新实例化问题")]),t._v(" "),n("p",[t._v("课利用 useRef 创造一个自定义 hook 代替 useCallback，使其 deps 变化时回调不会重新执行，但却能拿到最新值")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function useEventCallback(fn, dependencies) {\n  const ref = useRef(null);\n\n  useEffect(() => {\n    // fn 回调函数变化时，ref.current 指向最新的 fn\n    ref.current = fn;\n  }, [fn, ...deps]); // deps 变化时，也为 ref.current 重新赋值，此时 fn 内部的 deps 也是最新的\n\n  return useCallback(() => {\n    const fn = ref.current;\n    return fn();\n  }, [ref]); // 依赖不会变，所以每次都可以返回 deps 最新的 fn，且 fn 不会重新执行\n}\n")])])]),n("p",[t._v("以上代码还是利用了capture values 的概念，即每次渲染的闭包中，回调函数拿到的总是最新 render 闭包中的那个，所以 deps 的值永远是最新的，且函数不会被重新初始化")]),t._v(" "),n("h4",{attrs:{id:"应用场景-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-5"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),n("ul",[n("li",[t._v("useRef 是所有 Hooks API 中唯一一个返回 mutable 数据的")]),t._v(" "),n("li",[t._v("修改 useRef 值的唯一方法是修改其 current 的值，且值的变更不会引起 re-render")]),t._v(" "),n("li",[t._v("每次组件 re-render 时 iseRef 都返回固定不变的值")])]),t._v(" "),n("h4",{attrs:{id:"q-a-5"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q-a-5"}},[t._v("#")]),t._v(" Q&A")]),t._v(" "),n("h5",{attrs:{id:"为什么-useref-是唯一一个返回-mutable-数据的-hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#为什么-useref-是唯一一个返回-mutable-数据的-hook"}},[t._v("#")]),t._v(" 为什么 useRef 是唯一一个返回 mutable 数据的 hook？")]),t._v(" "),n("ul",[n("li",[t._v("非 useRef 相关的 hooks api，本质都形成了闭包，闭包有自己独立的状态，这就是 capture values 的本质")]),t._v(" "),n("li",[t._v("所有 hooks api 都具有 capture values 特性，除了 useRef\n"),n("ul",[n("li",[t._v("见如下代码（始终能拿到 state 最新值），state 是 immutable 的（setState 后一定会生成一个全新的 state 引用，故而每次"),n("code",[t._v("setTimeout")]),t._v("都读取了当前渲染闭包环境的数据，虽然新的值跟着最新的渲染变了，但旧的渲染中状态仍然是旧值），ref 是 mutable 的")]),t._v(" "),n("li",[t._v("通过 useRef 创建的对象，其值只有一份，且在每次的 render 中都共享")])])])]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function App() {\n  const [count, setCount] = useState(0);\n  const countRef = useRef(count);\n  console.log('组件重新渲染', count);\n\n  useEffect(() => {\n    // 改变 useRef 的原始值\n    countRef.current = count;\n\n    setTimeout(() => {\n      // setTimeout useRef.current 里边始终能拿到 state 最新值，快速点击 3 次执行结果为 3 3 3\n      console.log(`current count is ${countRef.current}`);\n      // setTimeout state 每次都读取了当前闭包环境的数据，快速点击 3 次执行结果为 1 2 3\n      console.log(`current count is ${state}`);\n    }, 3000);\n  }, [count]);\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n}\n")])])]),n("h3",{attrs:{id:"usememo"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usememo"}},[t._v("#")]),t._v(" UseMemo")]),t._v(" "),n("h4",{attrs:{id:"api-示例-6"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#api-示例-6"}},[t._v("#")]),t._v(" API 示例")]),t._v(" "),n("h5",{attrs:{id:"使用-usememo-做局部-purerender"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-usememo-做局部-purerender"}},[t._v("#")]),t._v(" 使用 useMemo 做局部 pureRender")]),t._v(" "),n("p",[t._v("用 useMemo 包裹渲染代码，这样就算 Child 因为 props 变动而 re-render 了，只要 useMemo 的 deps 中声明的参数 props.fetchData 经过浅对比后发现相等，就不会 re-render 渲染函数")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const Child = (props) => {\n  useEffect(() => {\n    props.fetchData()\n  }, [props.fetchData])\n\n  return useMemo(() => (\n    // ... 渲染代码\n  ), [props.fetchData])\n}\n")])])]),n("h4",{attrs:{id:"应用场景-6"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#应用场景-6"}},[t._v("#")]),t._v(" 应用场景")]),t._v(" "),n("h5",{attrs:{id:"memo-usecontext-做-function-组件间共享参数-函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#memo-usecontext-做-function-组件间共享参数-函数"}},[t._v("#")]),t._v(" memo + useContext 做 function 组件间共享参数 / 函数")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("// 这样就不需要在每个函数间进行参数透传了，公共函数可以都放在 Context 里\nconst Store = createContext(null);\n\nfunction Parent() {\n  const [count, setCount] = useState(0);\n  const [step, setStep] = useState(0);\n  const fetchData = useFetch(count, step);\n\n  return (\n    <Store.Provider value={{ setCount, setStep, fetchData }}>\n      <Child />\n    </Store.Provider>\n  );\n}\n\n// 用 memo 包裹的组件在 re-render 时会对 props 进行浅对比，没有变化就不会触发重渲染\nconst Child = memo((props) => {\n  const { setCount } = useContext(Store)\n\n  function onClick() {\n    setCount(count => count + 1)\n  }\n\n  return (\n    // ...\n  )\n})\n")])])]),n("p",[t._v("但当函数多了之后，provider 的 value 会非常臃肿，故而启用 useReducer 为 context 传递的内容进行瘦身")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("const Store = createContext(null);\n\n// 所有回调函数都通过调用 dispatch 完成，则 provider 仅需传递 dispatch 一个函数\nfunction Parent() {\n  const [state, dispatch] = useReducer(reducer, { count: 0, step: 0 });\n\n  return (\n    <Store.Provider value={dispatch}>\n      <Child />\n    </Store.Provider>\n  );\n}\n\nconst Child = useMemo((props) => {\n  const dispatch = useContext(Store)\n\n  function onClick() {\n    dispatch({\n      type: 'countInc'\n    })\n  }\n\n  return (\n    // ...\n  )\n})\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case \"tick\":\n      return {\n        ...state,\n        count: state.count + state.step\n      };\n  }\n}\n")])])]),n("p",[t._v("既然赋值的 dispatch 函数能共享，那么把 state 也放到 provider 的 value 里，赋值和读取岂不是变得更简单了？但 **state 放到 context 中会存在潜在性能问题！！ **")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const Store = createContext(null);\n\nfunction Parent() {\n  const [state, dispatch] = useReducer(reducer, { count: 0, step: 0 });\n\n  return (\n    <Store.Provider value={{ state, dispatch }}>\n      <Count />\n      <Step />\n    </Store.Provider>\n  );\n}\n\nconst Count = memo(() => {\n  const { state, dispatch } = useContext(Store);\n  return (\n    <button onClick={() => dispatch("incCount")}>incCount {state.count}</button>\n  );\n});\n\nconst Step = memo(() => {\n  const { state, dispatch } = useContext(Store);\n  return (\n    <button onClick={() => dispatch("incStep")}>incStep {state.step}</button>\n  );\n});\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case "tick":\n      return {\n        ...state,\n        count: state.count + state.step\n      };\n  }\n}\n')])])]),n("p",[t._v("出现的结果是无论点击 "),n("code",[t._v("incCount")]),t._v(" 还是 "),n("code",[t._v("incStep")]),t._v("，都会同时触发两个组件的 re-render，其问题在于 memo 只能挡住最外层的 props 传入，但通过 useContext 注入在函数内部的数据，会绕过 memo")]),t._v(" "),n("p",[t._v("当触发 dispatch 导致 state 的引用变化时，所有使用了 state 的组件都会触发 re-render，那么就需要用 useMemo 了")]),t._v(" "),n("h5",{attrs:{id:"usememo-usecontext-做-function-组件间共享参数-函数"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usememo-usecontext-做-function-组件间共享参数-函数"}},[t._v("#")]),t._v(" useMemo + useContext 做 function 组件间共享参数 / 函数")]),t._v(" "),n("p",[t._v("如果组件使用了 useContext，且不使用 props，就可以完全使用 useMemo 来做性能优化")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const Store = createContext(null);\n\nfunction Parent() {\n  const [state, dispatch] = useReducer(reducer, { count: 0, step: 0 });\n\n  return (\n    <Store.Provider value={{ state, dispatch }}>\n      <Count />\n      <Step />\n    </Store.Provider>\n  );\n}\n\nconst Count = () => {\n  const { state, dispatch } = useContext(Store);\n  return useMemo(\n    () => (\n      <button onClick={() => dispatch("incCount")}>\n        incCount {state.count}\n      </button>\n    ),\n    [state.count, dispatch]\n  );\n};\n\nconst Step = () => {\n  const { state, dispatch } = useContext(Store);\n  return useMemo(\n    () => (\n      <button onClick={() => dispatch("incStep")}>incStep {state.step}</button>\n    ),\n    [state.step, dispatch]\n  );\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case "tick":\n      return {\n        ...state,\n        count: state.count + state.step\n      };\n  }\n}\n')])])]),n("blockquote",[n("p",[t._v("useMemo 类似 redux 的 connect")])]),t._v(" "),n("h4",{attrs:{id:"q-a-6"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#q-a-6"}},[t._v("#")]),t._v(" Q&A")]),t._v(" "),n("h5",{attrs:{id:"usememo-和-memo-有什么区别"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usememo-和-memo-有什么区别"}},[t._v("#")]),t._v(" useMemo 和 memo 有什么区别")]),t._v(" "),n("ul",[n("li",[t._v("memo 包裹的函数会对 props 的每一项进行浅对比，没有变化就不会触发组件的 re-render")]),t._v(" "),n("li",[t._v("useMemo(() => {}, []) 可以结合 "),n("a",{attrs:{href:"https://www.npmjs.com/package/eslint-plugin-react-hooks",target:"_blank",rel:"noopener noreferrer"}},[t._v("eslint-plugin-react-hooks"),n("OutboundLink")],1),t._v("  实现更细粒度的性能优化，可指定个别 props 参数作为 deps，deps 没有变化就不会触发函数的 re-render")])]),t._v(" "),n("h2",{attrs:{id:"其他-hooks-api"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#其他-hooks-api"}},[t._v("#")]),t._v(" 其他 Hooks API")]),t._v(" "),n("h3",{attrs:{id:"uselayouteffect"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#uselayouteffect"}},[t._v("#")]),t._v(" UseLayoutEffect")]),t._v(" "),n("p",[t._v("和 useEffect 一致，区别只有执行时机，是在 dom 绘制之前执行的（和 "),n("code",[t._v("componentDidMount")]),t._v("、"),n("code",[t._v("componentDidUpdate")]),t._v("执行时机相同）")]),t._v(" "),n("h3",{attrs:{id:"usedebugvalue"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#usedebugvalue"}},[t._v("#")]),t._v(" UseDebugValue")]),t._v(" "),n("p",[t._v("用于开发者工具调试")]),t._v(" "),n("h3",{attrs:{id:"useimperativehandle"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#useimperativehandle"}},[t._v("#")]),t._v(" UseImperativeHandle")]),t._v(" "),n("p",[t._v("配合 forwardRef 使用，用于自定义通过 ref 给父组件暴露的值")]),t._v(" "),n("h2",{attrs:{id:"自定义-hook"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自定义-hook"}},[t._v("#")]),t._v(" 自定义 Hook")]),t._v(" "),n("p",[t._v("只要函数名遵循以 "),n("code",[t._v("use")]),t._v("开头，且返回非 JSX 元素，就可以创建自定义的 hooks。自定义 hooks 内还可以调用包括内置 hooks 在内的所有自定义 hooks，如下：")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function useCurrentValue(value) {\n  const ref = useRef(0)l\n  useEffect(() => {\n    ref.current = value;\n  }, [value]);\n  \n  return ref;\n}\n\nfunction Counter() {\n  const [count, setCount] = useState(0);\n  const currentCount = useCurrentValue(count);\n\n  const log = () => {\n    setCount(count + 1);\n    setTimeout(() => {\n      console.log(currentCount.current);\n    }, 3000);\n  };\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={log}>Click me</button>\n    </div>\n  );\n}\n")])])]),n("h4",{attrs:{id:"自定义-hook-处理副作用"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#自定义-hook-处理副作用"}},[t._v("#")]),t._v(" 自定义 Hook 处理副作用")]),t._v(" "),n("p",[t._v("举例：异步从接口里获取数据，最佳的做法是封装成一个自定义 hook")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const useDataApi<T> = (initialUrl: string, initialData: T) => {\n  const [url, setUrl] = useState(initialUrl);\n\n  const [state, dispatch] = useReducer(dataFetchReducer, {\n    isLoading: false,\n    isError: false,\n    data: initialData\n  });\n\n  useEffect(() => {\n    let didCancel = false;\n\n    const fetchData = async () => {\n      dispatch({ type: "FETCH_INIT" });\n\n      try {\n        const result = await axios(url);\n        if (!didCancel) {\n          dispatch({ type: "FETCH_SUCCESS", payload: result.data });\n        }\n      } catch (error) {\n        if (!didCancel) {\n          dispatch({ type: "FETCH_FAILURE" });\n        }\n      }\n    };\n\n    fetchData();\n\n    return () => {\n      didCancel = true;\n    };\n  }, [url]);\n\n  const doFetch = url => setUrl(url);\n\n  return { ...state, doFetch };\n};\n')])])]),n("p",[t._v("可以看到，自定义 Hook 拥有完整生命周期，我们可以将取数过程封装起来，只暴露状态")]),t._v(" "),n("ul",[n("li",[t._v("是否在加载中："),n("code",[t._v("isLoading")])]),t._v(" "),n("li",[t._v("是否取数失败："),n("code",[t._v("isError")])]),t._v(" "),n("li",[t._v("数据："),n("code",[t._v("data")])])]),t._v(" "),n("p",[t._v("在组件中使用非常方便")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function App() {\n  const { data, isLoading, isError } = useDataApi("https://v", {\n    showLog: true\n  });\n}\n')])])]),n("p",[t._v("如果这个值需要存储到数据流，在所有组件之间共享，可以结合 useEffect 和 useReducer")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('function App(props) {\n  const { dispatch } = useContext(Store);\n\n  const { data, isLoading, isError } = useDataApi("https://v", {\n    showLog: true\n  });\n\n  useEffect(() => {\n    dispatch({\n      type: "updateLoading",\n      data,\n      isLoading,\n      isError\n    });\n  }, [dispatch, data, isLoading, isError]);\n}\n')])])]),n("h2",{attrs:{id:"function-组件的-defaultprops"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#function-组件的-defaultprops"}},[t._v("#")]),t._v(" Function 组件的 defaultProps")]),t._v(" "),n("p",[t._v("先举个例子，用 es6 特性给参数定义阶段赋值")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 每次父组件刷新时，Child 组件跟着刷新，看起来 log 只会打印一次，实际每次渲染都会打印 log，证明 type 每次的引用都是不同的\nconst Child = memo(({ type = { a: 1 } }) => {\n  useEffect(() => {\n    console.log("type", type);\n  }, [type]);\n\n  return <div>Child</div>;\n});\n')])])]),n("p",[t._v("这种方法看似优雅，实际有个重大隐患：没有命中的 props 每次渲染引用都不同")]),t._v(" "),n("h3",{attrs:{id:"使用-react-内置方案"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#使用-react-内置方案"}},[t._v("#")]),t._v(" 使用 React 内置方案")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 不断刷新父组件，只会打印一次 log\nconst Child = ({ type }) => {\n  useEffect(() => {\n    console.log("type", type);\n  }, [type]);\n\n  return <div>Child</div>;\n};\n\nChild.defaultProps = {\n  type: { a: 1 }\n};\n')])])]),n("p",[t._v("建议使用 react 的内置方案，因为纯函数的方案不利于保持引用不变")]),t._v(" "),n("h2",{attrs:{id:"注意事项-2"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#注意事项-2"}},[t._v("#")]),t._v(" 注意事项")]),t._v(" "),n("h3",{attrs:{id:"父组件传对象给子组件导致的问题"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#父组件传对象给子组件导致的问题"}},[t._v("#")]),t._v(" 父组件传对象给子组件导致的问题")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('// 做一个点击累加的按钮作为父组件，那么父组件每次点击后都会刷新\nfunction Parent() {\n  const [count, forceUpdate] = useState(0);\n\n  const schema = { b: 1 };\n\n  return (\n    <div>\n      <Child schema={schema} />\n      <div onClick={() => forceUpdate(count + 1)}>Count {count}</div>\n    </div>\n  );\n}\n\nconst Child = memo(props => {\n  useEffect(() => {\n    console.log("schema", props.schema);\n  // props.schema 声明失效\n  }, [props.schema]);\n\n  return <div>Child</div>;\n});\n')])])]),n("p",[t._v("我们希望只有当 props.schema 变化就会触发 child 组件打印 log，但实际每次父组件刷新时 Child 就会打印 log，即 [props.schema] 完全失效，因为每次刷新后，props.schema 的值虽然不变，但引用都在变，而 hook 函数的 deps 是浅对比")]),t._v(" "),n("p",[t._v("解法一：改写子组件的依赖")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v('const Child = memo(props => {\n  useEffect(() => {\n    console.log("schema", props.schema);\n  // props.schema 声明失效\n  }, [JSON.stringfy(props.schema)]);\n\n  return <div>Child</div>;\n});\n')])])]),n("p",[t._v("解法二：ref 优化父组件传值")]),t._v(" "),n("div",{staticClass:"language-react extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[t._v("function Parent() {\n  const [count, forceUpdate] = useState(0);\n\n  const schema = useRef({ b: 1 });\n\n  return (\n    <div>\n      <Child schema={schema.current} />\n      <div onClick={() => forceUpdate(count + 1)}>Count {count}</div>\n    </div>\n  );\n}\n")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);